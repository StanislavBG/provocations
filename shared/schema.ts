import { z } from "zod";

// ── Persona types (each persona provides Advice and Challenge feedback) ──

export const provocationType = [
  "architect",
  "quality_engineer",
  "ux_designer",
  "tech_writer",
  "product_manager",
  "security_engineer",
  "ceo",
] as const;

export type ProvocationType = typeof provocationType[number];

// ── Persona JSON Schema ──
// Central definition for all personas. Each persona can generate challenges
// and advice through separate invocations. The persona is included in every
// challenge/advice output so the dialogue panel knows who is speaking.

export const personaColorSchema = z.object({
  text: z.string(),       // tailwind text color class e.g. "text-cyan-600 dark:text-cyan-400"
  bg: z.string(),         // tailwind bg color class e.g. "bg-cyan-50 dark:bg-cyan-950/30"
  accent: z.string(),     // accent hex color for charts/highlights e.g. "#0891b2"
});

export type PersonaColor = z.infer<typeof personaColorSchema>;

export const personaPromptsSchema = z.object({
  challenge: z.string(),  // system prompt for generating challenges from this persona
  advice: z.string(),     // system prompt for generating advice from this persona
});

export type PersonaPrompts = z.infer<typeof personaPromptsSchema>;

export const personaSummarySchema = z.object({
  challenge: z.string(),  // short tooltip-style summary of challenge behavior
  advice: z.string(),     // short tooltip-style summary of advice behavior
});

export type PersonaSummary = z.infer<typeof personaSummarySchema>;

export const personaSchema = z.object({
  id: z.string(),                           // unique key e.g. "architect" (matches ProvocationType)
  label: z.string(),                        // display name e.g. "Architect", "CEO"
  icon: z.string(),                         // lucide icon name e.g. "Blocks", "Rocket"
  role: z.string(),                         // one-line role summary
  description: z.string(),                  // longer description of what this persona does
  color: personaColorSchema,                // color scheme for rendering
  prompts: personaPromptsSchema,            // system prompts for challenge and advice generation
  summary: personaSummarySchema,            // short UI tooltip descriptions
  isBuiltIn: z.boolean().default(true),     // true for the 7 built-in personas; false for user-created
});

export type Persona = z.infer<typeof personaSchema>;

// ── Challenge schema ──
// A challenge is generated by a persona based on the document and objective.
// It presents a problem/gap without providing advice (advice is separate).

export const challengeSchema = z.object({
  id: z.string(),
  persona: personaSchema,                   // the full persona definition that issued this challenge
  title: z.string(),                        // punchy headline (max 60 chars)
  content: z.string(),                      // 2-3 sentence challenge explanation
  sourceExcerpt: z.string(),               // relevant quote from the document (max 150 chars)
  status: z.enum(["pending", "addressed", "rejected", "highlighted"]),
  scale: z.number().min(1).max(5).optional(), // impact: 1=minor to 5=critical
});

export type Challenge = z.infer<typeof challengeSchema>;

// ── Advice schema ──
// Advice is generated on-demand for a specific challenge, from the same persona.
// Requires a separate invocation so it is not a reiteration of the challenge.

export const adviceStatusValues = ["pending", "accepted", "rejected", "modified"] as const;

export const adviceSchema = z.object({
  id: z.string(),
  challengeId: z.string(),                 // links back to the originating challenge
  persona: personaSchema,                   // same persona that issued the challenge
  content: z.string(),                      // the advice text from this persona's perspective
  status: z.enum(adviceStatusValues),
  modifiedContent: z.string().optional(),   // user's edited version (when status === "modified")
});

export type Advice = z.infer<typeof adviceSchema>;

// ── Generate challenge request ──

export const generateChallengeRequestSchema = z.object({
  document: z.string().min(1, "Document is required"),         // current draft to challenge
  objective: z.string().min(1, "Objective is required"),       // what the document is trying to achieve
  personaIds: z.array(z.string()).optional(),                  // filter to specific personas; empty = all
  guidance: z.string().optional(),                             // user-specific focus area
  referenceDocuments: z.array(z.lazy(() => referenceDocumentSchema)).optional(),
});

export type GenerateChallengeRequest = z.infer<typeof generateChallengeRequestSchema>;

// ── Generate advice request ──

export const generateAdviceRequestSchema = z.object({
  document: z.string().min(1, "Document is required"),        // current draft — the persona reads this
  objective: z.string().min(1, "Objective is required"),      // what the document is trying to achieve
  challengeId: z.string().min(1, "Challenge ID is required"), // which challenge to advise on
  challengeTitle: z.string().min(1, "Challenge title is required"),
  challengeContent: z.string().min(1, "Challenge content is required"),
  personaId: z.string().min(1, "Persona ID is required"),     // which persona generates the advice
});

export type GenerateAdviceRequest = z.infer<typeof generateAdviceRequestSchema>;

// ── Legacy provocation schema (kept for backwards compatibility) ──

export const provocationScale = [1, 2, 3, 4, 5] as const;
export type ProvocationScale = typeof provocationScale[number];

export const provocationSchema = z.object({
  id: z.string(),
  type: z.enum(provocationType),
  title: z.string(),
  content: z.string(),
  sourceExcerpt: z.string(),
  status: z.enum(["pending", "addressed", "rejected", "highlighted"]),
  scale: z.number().min(1).max(5).optional(),
  autoSuggestion: z.string().optional(),
});

export type Provocation = z.infer<typeof provocationSchema>;

// Outline item schema
export const outlineItemSchema = z.object({
  id: z.string(),
  heading: z.string(),
  content: z.string(),
  order: z.number(),
  isExpanded: z.boolean(),
});

export type OutlineItem = z.infer<typeof outlineItemSchema>;

// Tone options
export const toneOptions = [
  "inspirational",
  "practical",
  "analytical",
  "persuasive",
  "cautious",
] as const;

export type ToneOption = typeof toneOptions[number];

// Document schema (in-memory only, no persistence needed)
export const documentSchema = z.object({
  id: z.string(),
  rawText: z.string(),
});

export type Document = z.infer<typeof documentSchema>;

// Reference document types (style guides, templates)
export const referenceDocumentSchema = z.object({
  id: z.string(),
  name: z.string(),
  content: z.string(),
  type: z.enum(["style", "template"]),
});

export type ReferenceDocument = z.infer<typeof referenceDocumentSchema>;

// API request schemas - used by both frontend and backend

// Unified write request - single interface to the AI writer
export const provocationContextSchema = z.object({
  type: z.enum(provocationType),
  title: z.string(),
  content: z.string(),
  sourceExcerpt: z.string(),
});

// Instruction types for classification-based writing strategies
export const instructionTypes = [
  "expand",      // Add detail, examples, elaboration
  "condense",    // Remove redundancy, tighten prose
  "restructure", // Reorder sections, add headings
  "clarify",     // Simplify language, add transitions
  "style",       // Change voice, formality level
  "correct",     // Fix errors, improve accuracy
  "general",     // General improvement
] as const;

export type InstructionType = typeof instructionTypes[number];

// Edit history entry for tracking iterations
export const editHistoryEntrySchema = z.object({
  instruction: z.string(),
  instructionType: z.enum(instructionTypes),
  summary: z.string(),
  timestamp: z.number(),
});

export type EditHistoryEntry = z.infer<typeof editHistoryEntrySchema>;

export const writeRequestSchema = z.object({
  // Foundation (always required)
  document: z.string().min(1, "Document is required"),
  objective: z.string().min(1, "Objective is required"),

  // Focus (optional - what part of document)
  selectedText: z.string().optional(),

  // Intent (required - what user wants)
  instruction: z.string().min(1, "Instruction is required"),

  // Context (optional - additional grounding)
  provocation: provocationContextSchema.optional(),

  // Style (optional)
  tone: z.enum(toneOptions).optional(),
  targetLength: z.enum(["shorter", "same", "longer"]).optional(),

  // Reference documents for style inference
  referenceDocuments: z.array(referenceDocumentSchema).optional(),

  // Edit history for coherent iteration
  editHistory: z.array(editHistoryEntrySchema).optional(),
});

export type WriteRequest = z.infer<typeof writeRequestSchema>;

// Change tracking for structured output
export const changeEntrySchema = z.object({
  type: z.enum(["added", "modified", "removed", "restructured"]),
  description: z.string(),
  location: z.string().optional(),
});

export type ChangeEntry = z.infer<typeof changeEntrySchema>;

export const writeResponseSchema = z.object({
  document: z.string(),
  summary: z.string().optional(),
  instructionType: z.enum(instructionTypes).optional(),
  changes: z.array(changeEntrySchema).optional(),
  suggestions: z.array(z.string()).optional(),
});

export type WriteResponse = z.infer<typeof writeResponseSchema>;

export interface DocumentVersion {
  id: string;
  text: string;
  timestamp: number;
  description: string;
}

// Direction mode for provoke panel (challenge = push back, advise = suggest improvements)
export const directionModes = ["challenge", "advise"] as const;
export type DirectionMode = typeof directionModes[number];

// CEO vectors — high-impact dimensions for scaling products
export const thinkBigVectors = [
  "tenancy_topology",
  "api_surface",
  "scaling_horizon",
  "data_residency",
  "integration_philosophy",
  "identity_access",
  "observability",
] as const;
export type ThinkBigVector = typeof thinkBigVectors[number];

// Interview entry - a single Q&A pair from the interview flow
export const interviewEntrySchema = z.object({
  id: z.string(),
  question: z.string(),
  answer: z.string(),
  topic: z.string(),
  timestamp: z.number(),
});

export type InterviewEntry = z.infer<typeof interviewEntrySchema>;

// ── Discussion message types (enhanced discussion panel) ──

// A single persona perspective in a multi-persona response
export const personaPerspectiveSchema = z.object({
  personaId: z.string(),
  personaLabel: z.string(),
  content: z.string(),
});

export type PersonaPerspective = z.infer<typeof personaPerspectiveSchema>;

// Discussion message — supports both AI questions and user questions
export const discussionMessageSchema = z.object({
  id: z.string(),
  role: z.enum(["system-question", "user-answer", "user-question", "persona-response"]),
  content: z.string(),
  topic: z.string().optional(),
  timestamp: z.number(),
  // For persona responses — individual perspectives from each relevant persona
  perspectives: z.array(personaPerspectiveSchema).optional(),
  // Interaction status for persona responses
  status: z.enum(["pending", "accepted", "dismissed"]).optional(),
  // Advice loaded on demand for system questions
  advice: z.string().optional(),
  advicePersonaId: z.string().optional(),
  adviceLoading: z.boolean().optional(),
});

export type DiscussionMessage = z.infer<typeof discussionMessageSchema>;

// Ask question request — user asks a question to the persona team
export const askQuestionRequestSchema = z.object({
  question: z.string().min(1, "Question is required"),
  document: z.string().min(1, "Document is required"),
  objective: z.string().min(1, "Objective is required"),
  secondaryObjective: z.string().optional(),
  activePersonas: z.array(z.string()).optional(),
  previousMessages: z.array(discussionMessageSchema).optional(),
});

export type AskQuestionRequest = z.infer<typeof askQuestionRequestSchema>;

// Ask question response — multi-persona response
export interface AskQuestionResponse {
  answer: string;
  perspectives: PersonaPerspective[];
  relevantPersonas: string[];
  topic: string;
}

// Interview question request - generates the next provocative question
export const interviewQuestionRequestSchema = z.object({
  objective: z.string().min(1, "Objective is required"),
  document: z.string().optional(),
  template: z.string().optional(),
  previousEntries: z.array(interviewEntrySchema).optional(),
  provocations: z.array(provocationSchema).optional(),
  // Direction parameters for the provoke panel
  directionMode: z.enum(directionModes).optional(),
  directionPersonas: z.array(z.enum(provocationType)).optional(),
  directionGuidance: z.string().optional(),
  thinkBigVectors: z.array(z.enum(thinkBigVectors)).optional(),
});

export type InterviewQuestionRequest = z.infer<typeof interviewQuestionRequestSchema>;

// Interview question response
export interface InterviewQuestionResponse {
  question: string;
  topic: string;
  reasoning: string;
}

// Interview summary request - summarize all entries for merge
export const interviewSummaryRequestSchema = z.object({
  objective: z.string().min(1, "Objective is required"),
  entries: z.array(interviewEntrySchema).min(1, "At least one entry is required"),
  document: z.string().optional(),
});

export type InterviewSummaryRequest = z.infer<typeof interviewSummaryRequestSchema>;

export interface WorkspaceState {
  document: Document | null;
  objective: string;
  referenceDocuments: ReferenceDocument[];
  editHistory: EditHistoryEntry[];
  provocations: Provocation[];
  outline: OutlineItem[];
  currentPhase: "input" | "blank-document" | "workspace";
}

// Document save/load schemas (server-side encryption, Clerk auth for ownership)
export const saveDocumentRequestSchema = z.object({
  title: z.string().min(1, "Title is required").max(200),
  content: z.string().min(1, "Content is required"),
});

export type SaveDocumentRequest = z.infer<typeof saveDocumentRequestSchema>;

export const updateDocumentRequestSchema = z.object({
  title: z.string().min(1, "Title is required").max(200),
  content: z.string().min(1, "Content is required"),
});

export const renameDocumentRequestSchema = z.object({
  title: z.string().min(1, "Title is required").max(200),
});

export type RenameDocumentRequest = z.infer<typeof renameDocumentRequestSchema>;

export type UpdateDocumentRequest = z.infer<typeof updateDocumentRequestSchema>;

export interface DocumentListItem {
  id: number;
  title: string;
  createdAt: string;
  updatedAt: string;
}

export interface DocumentPayload {
  id: number;
  title: string;
  content: string;
  createdAt: string;
  updatedAt: string;
}

// ── Streaming provocation type ──
// Streaming supports requirement discovery through a side-by-side wireframe + dialogue experience.

export const workspaceMode = ["standard", "streaming"] as const;
export type WorkspaceMode = typeof workspaceMode[number];

// A single entry in the streaming dialogue (agent question + user answer)
export const streamingDialogueEntrySchema = z.object({
  id: z.string(),
  role: z.enum(["agent", "user"]),
  content: z.string(),
  timestamp: z.number(),
});

export type StreamingDialogueEntry = z.infer<typeof streamingDialogueEntrySchema>;

// A single requirement extracted from the streaming dialogue
export const streamingRequirementSchema = z.object({
  id: z.string(),
  text: z.string(),
  status: z.enum(["draft", "confirmed", "revised"]),
  timestamp: z.number(),
});

export type StreamingRequirement = z.infer<typeof streamingRequirementSchema>;

// Request to generate the next streaming question
export const streamingQuestionRequestSchema = z.object({
  objective: z.string().min(1, "Objective is required"),
  document: z.string().optional(),
  websiteUrl: z.string().optional(),
  wireframeNotes: z.string().optional(),
  previousEntries: z.array(streamingDialogueEntrySchema).optional(),
  requirements: z.array(streamingRequirementSchema).optional(),
});

export type StreamingQuestionRequest = z.infer<typeof streamingQuestionRequestSchema>;

// Response from streaming question endpoint
export interface StreamingQuestionResponse {
  question: string;
  topic: string;
  suggestedRequirement?: string;
}

// Request to analyze wireframe components
export const wireframeAnalysisRequestSchema = z.object({
  objective: z.string().min(1, "Objective is required"),
  websiteUrl: z.string().optional(),
  wireframeNotes: z.string().optional(),
  document: z.string().optional(),
});

export type WireframeAnalysisRequest = z.infer<typeof wireframeAnalysisRequestSchema>;

// Structured content discovery item
export interface SiteMapEntry {
  url: string;
  title: string;
  depth: number; // 0 = landing page, 1 = direct child, etc.
}

export interface DiscoveredMedia {
  url: string;
  title: string;
  type?: string; // e.g. "mp4", "webm", "mp3", "rss+xml"
}

// Response from wireframe analysis
export interface WireframeAnalysisResponse {
  analysis: string;
  components: string[];
  suggestions: string[];
  // Structured content discovery (populated async)
  siteMap?: SiteMapEntry[];
  videos?: DiscoveredMedia[];
  audioContent?: DiscoveredMedia[];
  rssFeeds?: DiscoveredMedia[];
  images?: DiscoveredMedia[];
  primaryContent?: string; // Main textual content extracted from the site
  contentScanStatus?: "pending" | "scanning" | "complete";
}

// Wireframe analysis schema for passing to refine endpoint
export const wireframeAnalysisSchema = z.object({
  analysis: z.string(),
  components: z.array(z.string()),
  suggestions: z.array(z.string()),
  siteMap: z.array(z.object({
    url: z.string(),
    title: z.string(),
    depth: z.number(),
  })).optional(),
  videos: z.array(z.object({ url: z.string(), title: z.string(), type: z.string().optional() })).optional(),
  audioContent: z.array(z.object({ url: z.string(), title: z.string(), type: z.string().optional() })).optional(),
  rssFeeds: z.array(z.object({ url: z.string(), title: z.string(), type: z.string().optional() })).optional(),
  images: z.array(z.object({ url: z.string(), title: z.string(), type: z.string().optional() })).optional(),
  primaryContent: z.string().optional(),
  contentScanStatus: z.enum(["pending", "scanning", "complete"]).optional(),
}).optional();

// Request to refine requirements from streaming dialogue
export const streamingRefineRequestSchema = z.object({
  objective: z.string().min(1, "Objective is required"),
  dialogueEntries: z.array(streamingDialogueEntrySchema).min(1, "At least one dialogue entry is required"),
  existingRequirements: z.array(streamingRequirementSchema).optional(),
  document: z.string().optional(),
  websiteUrl: z.string().optional(),
  wireframeAnalysis: wireframeAnalysisSchema,
});

export type StreamingRefineRequest = z.infer<typeof streamingRefineRequestSchema>;

export interface StreamingRefineResponse {
  requirements: StreamingRequirement[];
  updatedDocument: string;
  summary: string;
}
